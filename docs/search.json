[
  {
    "objectID": "posts/augmentation_is_regularization/augmentation_is_regularization.html",
    "href": "posts/augmentation_is_regularization/augmentation_is_regularization.html",
    "title": "Augmentation is Regularization",
    "section": "",
    "text": "Training data augmentation enhances the training dataset by applying transformations to existing training data instances. The specific transformations vary depending on the type of data involved, and this flexibility allows to leverage domain knowledge, such as known invariants, effectively. The goal is to introduce variability and increase the diversity of the training set, allowing the model to better generalize to unseen data and exhibit improved robustness. Despite the advantages, training data augmentation introduces an inherent computational cost: the increased volume of data requires additional computational resources, impacting both training time and memory requirements.\nAs we will show below, for linear models with the sum of squares loss, training data augmentation is equivalent to adding quadratic regularization term, which implies that the computational cost of fitting a model to an augmented dataset is the same as using no augmentation at all!\nThis link between augmentation and regularization is useful in the other direction as well: it gives a concrete interpretation to the value of regularization hyperparameters, and can be used to avoid costly hyperparameters tuning (np.logspace(-6, 6, 100) much?), and to design regularizers that are more appropriate to the data than the simple ones (i.e sum of squares regularization used in ridge regression).\n\n\nSuppose we have a training data set comprised of \\(n\\) pairs \\(x_i,\\,y_i\\) for \\(i=0, \\dots, n-1\\), where \\(x_i\\) is the \\(d\\) dimensional feature vector of the \\(i\\)’th training data, and \\(y_i\\) is the corresponding label. Here we will assume \\(y_i \\in \\mathrm{R}\\), however our results can be easily extended to the vector-labeled (aka multi-output) case. We will also denote by \\(X\\) the \\(n\\)-by-\\(d\\) matrix with rows \\(x_0^T, \\dots, x_{n-1}^T\\) and by \\(y\\) the \\(n\\)-vector with entries \\(y_0, \\dots, y_{n-1}\\).\nLet \\(a:\\mathrm{R}^d \\times \\mathcal{P}  \\mapsto \\mathrm{R}^d\\) denote the augmentation function that given the augmentation params \\(p \\in \\mathcal{P}\\), maps a feature vector \\(x\\) to a transformed feature vector. The augmentation parameters \\(p\\) are usually sampled randomly from a given distribution. For example, for image data, \\(a\\) is often a composition of small shifts, rotations, brightness changes, etc. while \\(p\\) specifies the amount of shifting, rotation and brightness change.\n\n\n\nLet’s quickly discuss OLS so we can compare it’s equations with the augmented version we will derive after.\nTo fit an OLS model, we find a vector of coefficients \\(\\theta_\\text{OLS}\\) that minimizes the sum of squared training errors: \\[\\begin{align*}\n    \\theta_\\text{OLS} &:= \\text{argmin} _\\theta \\sum_{i=0} ^{n-1} \\left(\n    x_i ^T \\theta - y_i\n    \\right) ^2\n    \\\\&= \\text{argmin} _\\theta \\| X \\theta - y \\|^2 \\tag{1}\n\\end{align*}\\] To solve the optimization problem (1), we solve the equation \\(X^TX \\theta_\\text{OLS} = X^T y\\), which has time complexity \\(O(n d^2)\\).\n\n\n\nWe will now fit a model by finding coefficients \\(\\theta_\\text{ALS}\\) that minimize the expected error over the augmented training dataset: \\[\\begin{align*}\n    \\theta_\\text{ALS} &:= \\text{argmin} _\\theta \\mathrm{E}  \n    \\left[\n    \\sum_{i=0} ^{n-1} \\left(\n    a\\left(x_i, p_i\\right) ^T \\theta - y_i\n    \\right) ^2\n    \\right], \\tag{2}\n\\end{align*}\\] where the expectation is over \\(p_0,\\dots, p_{n-1}\\), the random augmentation parameters. As we will see below, \\(\\theta_\\text{ALS}\\) depends on \\(a\\) and the distribution of \\(p\\) only through the 2nd order moments, which we denote by \\[\\begin{align*}\n    \\mu_i &:= \\mathrm{E} \\left[a(x_i, p_i) \\right]\\\\\n    R_i &:= \\mathrm{C}\\text{ov} \\left[ a(x_i, p_i) \\right].\n\\end{align*}\\]\nContinuing from (2), we use the standard trick of subtracting and adding the mean: \\[\\begin{align*}\n    \\theta_\\text{ALS} &= \\text{argmin} _\\theta \\mathrm{E}  \n    \\left[\n        \\sum_{i=0} ^{n-1} \\left(\n            \\left(\n                \\mu_i^T \\theta - y_i\n            \\right)\n            + \\left(\n                a\\left(x_i, p_i\\right) -\n                \\mu_i\n            \\right)^T\\theta\n        \\right) ^2\n    \\right]\n\\end{align*}\\] Note that the first term $ ( _i^T - y_i ) $ is deterministic, while the second term $ ( a(x_i, p_i) - _i )^T $ has zero mean. Therefore \\[\\begin{align*}\n    \\theta_\\text{ALS} &= \\text{argmin} _\\theta\n    \\sum_{i=0} ^{n-1}\n        \\left(\n            \\mu_i^T \\theta - y_i\n        \\right)\n        +\n        \\mathrm{E} \\left[\\left(\n            \\left(\n                a\\left(x_i, p_i\\right) -\n                \\mu_i\n            \\right)^T\\theta\n        \\right)^2 \\right] \\\\\n    &= \\text{argmin} _\\theta\n    \\| M \\theta - y\\|^2 + \\theta ^T R \\theta,\n    \\tag{3}\n\\end{align*}\\] where \\(M\\) is the \\(n\\)-by-\\(d\\) matrix whose rows are \\(\\mu_0^T, \\dots, \\mu_{n-1}^T\\), and \\[\nR := \\sum_{i=0} ^{n-1} R_i.\n\\] Equation (3) shows exactly what we set to prove - fitting a model on augmented training dataset, is equivalent to fitting a non-augmented, but quadratically regularized, least squares model. We just replace \\(X\\) with it’s mean, and use the sum of all covariances as the regularization matrix.\nTo solve the optimization problem (3), we solve the equation \\((X^T X + R) \\theta_\\text{ALS} = X^T y\\), which has the same \\(O(n d^2)\\) complexity as OLS.\n\n\n\nRide regression (aka Tykhonov regularization) has the form (3) with \\(M=X\\) and \\(R=\\lambda I\\). As an augmentation, it can be interpreted as follows: perturb each feature vector by a zero mean noise, with variance \\(\\lambda/n\\), uncorrelated across features.\nThis interpretation of \\(\\lambda\\) can be used to set it (at least roughly): just think what level of perturbation \\(\\sigma\\) is reasonable for your features, and set \\(\\lambda = n \\sigma^2\\).\nThis also shows that when different feature are scaled differently, ridge regression is perhaps not the best fit. A standard deviation of 100 might be reasonable for a feature with values in the order of millions, but it is probably not suitable for a feature with values in the order of 1. In these cases, we may use a diagonal \\(R\\): \\[\\begin{align*}\n    R= n \\, \\text{diag} \\left(\n        \\sigma_0^2, \\dots, \\sigma_{d-1}^2\n    \\right)\n\\end{align*}\\] where \\(\\sigma_i\\) is the standard deviation of the perturbation of feature \\(i\\).\nAnother option is to scale the transformations before fit, e.g using sklearn’s StandardScaler. With all features scaled to have unit variance, setting \\(\\lambda = n \\, 10 ^{-6}\\) is a sensible rule of thumb, as it is often reasonable to assume a \\(0.1\\%\\) perturbation.\nNote that often the model includes an intercept (aka constant) term by adding a column of ones to \\(X\\). Since this column remain unchanged through any augmenting transformation, the corresponding row and column of \\(R\\) should be all zeros.\n\n\n\nFor the example we are gonna use the House Sales in King County, USA dataset. Each row describes a house, sold between May 2014 and May 2015. Our goal will be to predict the log price given features like number of rooms, area, and geography.\nNote: several decisions outlined below weren’t necessarily the most effective,;, rather, they were chosen to showcase different modelling techniques in the context of augmentation via regularization.\nLet’s begin by importing everything we will need, loading our data, and adding some columns.\n\nfrom typing import Callable, Hashable, Self\n\nimport numpy as np\nfrom numpy.typing import NDArray\nimport pandas as pd\nimport scipy\nfrom sklearn.base import BaseEstimator\nfrom sklearn.cluster import KMeans\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.linear_model import LinearRegression, RidgeCV\nfrom sklearn.metrics import r2_score\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import StandardScaler\n\nArray = NDArray[np.float64]\n\ndf = pd.read_csv(\"data/kc_house_data.csv.zip\", parse_dates=[\"date\"])\ndf[\"long_scaled\"] = df[\"long\"] * np.mean(\n    np.abs(np.cos(df[\"lat\"] * np.pi / 180))\n)  # earth-curvature correction for (approximate) distance calculations\ndf.describe()\n\n\n\n\n\n\n\n\nid\ndate\nprice\nbedrooms\nbathrooms\nsqft_living\nsqft_lot\nfloors\nwaterfront\nview\n...\nsqft_above\nsqft_basement\nyr_built\nyr_renovated\nzipcode\nlat\nlong\nsqft_living15\nsqft_lot15\nlong_scaled\n\n\n\n\ncount\n2.161300e+04\n21613\n2.161300e+04\n21613.000000\n21613.000000\n21613.000000\n2.161300e+04\n21613.000000\n21613.000000\n21613.000000\n...\n21613.000000\n21613.000000\n21613.000000\n21613.000000\n21613.000000\n21613.000000\n21613.000000\n21613.000000\n21613.000000\n21613.000000\n\n\nmean\n4.580302e+09\n2014-10-29 04:38:01.959931648\n5.400881e+05\n3.370842\n2.114757\n2079.899736\n1.510697e+04\n1.494309\n0.007542\n0.234303\n...\n1788.390691\n291.509045\n1971.005136\n84.402258\n98077.939805\n47.560053\n-122.213896\n1986.552492\n12768.455652\n-82.471784\n\n\nmin\n1.000102e+06\n2014-05-02 00:00:00\n7.500000e+04\n0.000000\n0.000000\n290.000000\n5.200000e+02\n1.000000\n0.000000\n0.000000\n...\n290.000000\n0.000000\n1900.000000\n0.000000\n98001.000000\n47.155900\n-122.519000\n399.000000\n651.000000\n-82.677673\n\n\n25%\n2.123049e+09\n2014-07-22 00:00:00\n3.219500e+05\n3.000000\n1.750000\n1427.000000\n5.040000e+03\n1.000000\n0.000000\n0.000000\n...\n1190.000000\n0.000000\n1951.000000\n0.000000\n98033.000000\n47.471000\n-122.328000\n1490.000000\n5100.000000\n-82.548783\n\n\n50%\n3.904930e+09\n2014-10-16 00:00:00\n4.500000e+05\n3.000000\n2.250000\n1910.000000\n7.618000e+03\n1.500000\n0.000000\n0.000000\n...\n1560.000000\n0.000000\n1975.000000\n0.000000\n98065.000000\n47.571800\n-122.230000\n1840.000000\n7620.000000\n-82.482651\n\n\n75%\n7.308900e+09\n2015-02-17 00:00:00\n6.450000e+05\n4.000000\n2.500000\n2550.000000\n1.068800e+04\n2.000000\n0.000000\n0.000000\n...\n2210.000000\n560.000000\n1997.000000\n0.000000\n98118.000000\n47.678000\n-122.125000\n2360.000000\n10083.000000\n-82.411796\n\n\nmax\n9.900000e+09\n2015-05-27 00:00:00\n7.700000e+06\n33.000000\n8.000000\n13540.000000\n1.651359e+06\n3.500000\n1.000000\n4.000000\n...\n9410.000000\n4820.000000\n2015.000000\n2015.000000\n98199.000000\n47.777600\n-121.315000\n6210.000000\n871200.000000\n-81.865195\n\n\nstd\n2.876566e+09\nNaN\n3.671272e+05\n0.930062\n0.770163\n918.440897\n4.142051e+04\n0.539989\n0.086517\n0.766318\n...\n828.090978\n442.575043\n29.373411\n401.679240\n53.505026\n0.138564\n0.140828\n685.391304\n27304.179631\n0.095033\n\n\n\n\n8 rows × 22 columns\n\n\n\nWe will want a polynomial (rather than linear) dependency on the age of the house:\n\ndf[\"age\"] = df[\"date\"].dt.year - df[\"yr_built\"]\nage_cols = [\"age\"]\nfor power in range(2, 5):\n    col = f\"age ^ {power}\"\n    df[col] = df[\"age\"] ** power\n    age_cols.append(col)\n\nWe do a 10-90 train-test split to demonstrate the effectiveness of augmentation when we have little data.\n\ny = np.log(df[\"price\"])\nX = df.drop(columns=[\"price\"])\nx_train, x_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.9, random_state=42\n)\nprint(f\"{x_train.shape=}, {x_test.shape=}\")\n\nx_train.shape=(2161, 25), x_test.shape=(19452, 25)\n\n\nThere is no reason to expect a linear relationship between the house geographical coordinates and it’s price.\nHowever, we do expect a strong dependency between price and location in the sense that houses with similar features should share similar prices when located in close geographical proximity.\nOne way to model this is to cluster the data geographically, and tag each house with the cluster it belongs to using one hot encoding:\n\n# We need this class mainly since the transform method of sklearn's k-means class yields cluster centers, and we want one hot encoding.\nclass OneHotEncodedKMeansTransformer:\n    def __init__(self, k: int, columns: list[str], name: str) -&gt; None:\n        self.columns = columns\n        self.k = k\n        self.name = name\n\n    def fit(self, X: pd.DataFrame) -&gt; Self:\n        self.kmeans_ = KMeans(n_clusters=self.k, n_init=\"auto\", random_state=42)\n        self.kmeans_.fit(X[self.columns])\n        return self\n\n    def column_names(self) -&gt; list[str]:\n        return [f\"{self.name}_{i}\" for i in range(self.k)]\n\n    def transform(self, X: pd.DataFrame):\n        cluster_index = self.kmeans_.predict(X[self.columns])\n        return pd.concat(\n            [\n                X,\n                pd.DataFrame(\n                    np.eye(self.k)[cluster_index],\n                    columns=self.column_names(),\n                    index=X.index,\n                ),\n            ],\n            axis=1,\n        )\n\n    def clusters_adjacency_matrix(self):\n        edges = np.array(\n            scipy.spatial.Voronoi(self.kmeans_.cluster_centers_).ridge_points\n        ).T\n        a = scipy.sparse.coo_matrix(\n            (np.ones(edges.shape[1]), (edges[0], edges[1])),\n            shape=(self.k, self.k),\n        )\n        return a + a.T\n\n\nkmeans_transformer = OneHotEncodedKMeansTransformer(\n    k=500,\n    columns=[\"lat\", \"long_scaled\"],\n    name=\"geo_cluster\",\n)\nx_train = kmeans_transformer.fit(x_train).transform(x_train)\nx_test = kmeans_transformer.transform(x_test)\n\nWe will evaluate our models by their R squared score. From a quick glance over Kaggle, it seems that sophisticated and advanced models (e.g XGBoost) can achieve a score of about 0.9. Let’s see if we can get there using a linear model.\n\ndef evaluate_model(model) -&gt; None:\n    y_train_pred = model.fit(x_train, y_train).predict(x_train)\n    r2_train = r2_score(y_train, y_train_pred)\n    y_test_pred = model.predict(x_test)\n    r2_test = r2_score(y_test, y_test_pred)\n    print(f\"{r2_train=:.3f}, {r2_test=:.3f}\")\n\nLet’s start with a vanilla linear model, without any regularization/augmentations.\n\ncolumns = (\n    [\n        \"bedrooms\",\n        \"bathrooms\",\n        \"floors\",\n        \"waterfront\",\n        \"view\",\n        \"condition\",\n        \"grade\",\n        \"sqft_living\",\n        \"sqft_lot\",\n        \"sqft_above\",\n        \"sqft_basement\",\n        \"sqft_lot15\",\n        \"sqft_living15\",\n    ]\n    + age_cols\n    + kmeans_transformer.column_names()\n)\ncolumns_selector = ColumnTransformer(\n    [(\"selector\", \"passthrough\", columns)],\n    remainder=\"drop\",\n    verbose_feature_names_out=False,\n).set_output(transform=\"pandas\")\n\nsimple_linear = Pipeline(\n    [\n        (\"selector\", columns_selector),\n        (\"linear\", LinearRegression(fit_intercept=False)),\n    ]\n)\nevaluate_model(simple_linear)\n\nr2_train=0.918, r2_test=0.862\n\n\nNot bad, but we do have some overfitting. Let’s see if we can improve generalization with regularization/augmentation. First we try ridge regression:\n\nridge = Pipeline(\n    [\n        (\"selector\", columns_selector),\n        (\"scale\", StandardScaler()),\n        (\n            \"linear\",\n            RidgeCV(\n                fit_intercept=True,\n                alphas=x_train.shape[0] * np.logspace(-9, -2, 100),\n            ),\n        ),\n    ]\n)\nevaluate_model(ridge)\n\nr2_train=0.918, r2_test=0.863\n\n\nThat didn’t really help. That makes sense since using a diagonal regularization matrix doesn’t make sense for our correlated features.\nLet’s see if we can do better by using augmentations that are more appropriate for our data.\nFirst let’s build a class for linear models with augmentation via regularization.\nWe will pass to the constructor a callable that takes the input features and returns their mean and (sum of) covariance after the augmentation, since as we shown above these are all we need from the augmentations.\nSince often the transformations of different features are uncorrelated, it is convenient to specify features in groups, and assume zero covariance for features that are not in the same group (i.e a block diagonal covariance matrix).\n\nclass AugmentedLinearModel:\n    def __init__(\n        self,\n        augmentation_moments: list[  # one item for each group of features\n            tuple[\n                list[Hashable],  # column names of features in the group\n                Callable[[pd.DataFrame], tuple[Array, Array]],  # maps X to M and R\n            ]\n        ],\n    ) -&gt; None:\n        self.augmentation_moments = augmentation_moments\n\n    def fit(self, X: pd.DataFrame, y: pd.Series) -&gt; Self:\n        means, covs = zip(\n            *(\n                moments(X.loc[:, columns])\n                for columns, moments in self.augmentation_moments\n            )\n        )\n        M = np.hstack(means)\n        # https://scikit-learn.org/stable/developers/develop.html#estimated-attributes\n        self.R_ = scipy.linalg.block_diag(*covs)\n        self.theta_ = np.linalg.solve(M.T @ M + self.R_, M.T @ y)\n        return self\n\n    def predict(self, X: pd.DataFrame) -&gt; pd.Series:\n        cols = [col for cols, _ in self.augmentation_moments for col in cols]\n        return X.loc[:, cols] @ self.theta_\n\nHere are the augmentations we are gonna use:\nWith 10% probability, a bathroom is counted as half a bedroom.\n\ndef bedrooms_bathrooms_moments(X: pd.DataFrame) -&gt; tuple[Array, Array]:\n    p = 0.1\n    v = np.array([1, -0.5])\n    mask = X[[\"bathrooms\"]] &gt;= 1\n    M = np.where(mask, X + p * v, X)\n    R = p * (1 - p) * np.outer(v, v) * mask.values.sum()\n    return M, R\n\n\naugmentation_moments = [([\"bedrooms\", \"bathrooms\"], bedrooms_bathrooms_moments)]\n\nA 5% perturbation for the features\nsqft_living, sqft_lot, sqft_above, sqft_basement, sqft_lot15, sqft_living15, uncorrelated across the features.\n\ndef relative_perturbation_moments(X: pd.DataFrame) -&gt; tuple[Array, Array]:\n    return X.values, np.sum(X.values**2) * 0.05**2\n\n\naugmentation_moments.extend(\n    ([column], relative_perturbation_moments)\n    for column in [\n        \"sqft_living\",\n        \"sqft_lot\",\n        \"sqft_above\",\n        \"sqft_basement\",\n        \"sqft_lot15\",\n        \"sqft_living15\",\n    ]\n)\n\nA perturbation of 0.01 for the features floors, waterfront, view, condition, grade, uncorrelated across the features\n\ndef absolute_perturbation_moments(X: pd.DataFrame) -&gt; tuple[Array, Array]:\n    return X.values, X.shape[0] * 0.01**2\n\n\naugmentation_moments.extend(\n    ([column], absolute_perturbation_moments)\n    for column in [\"floors\", \"waterfront\", \"view\", \"condition\", \"grade\"]\n)\n\nperturbing age with a uniform distribution between -1 and 1. We need to calculate the moments for the power of age accordingly.\n\ndef age_moments(X: pd.DataFrame) -&gt; tuple[Array, Array]:\n    a = X[[\"age\"]].values - 1\n    b = X[[\"age\"]].values + 1\n    max_power = X.shape[1]\n    np1 = np.arange(2, 2 * max_power + 2)\n    # https://en.wikipedia.org/wiki/Continuous_uniform_distribution#Moments\n    mu = (b**np1 - a**np1) / (np1 * (b - a))\n    mu_sum = mu[:, 1:].sum(axis=0)\n    mu = mu[:, :max_power]\n    idx = np.add.outer(np.arange(max_power), np.arange(max_power))\n    c = mu_sum[idx] - mu.T @ mu\n    return mu, c\n\n\naugmentation_moments.append((age_cols, age_moments))\n\nAnd finally, with probability 50%, the geo cluster is changed to one of it’s neighbors.\n\ndef geo_cluster_moments(X: pd.DataFrame) -&gt; tuple[Array, Array]:\n    p = 0.5\n    adj_mat = kmeans_transformer.clusters_adjacency_matrix()\n    P = scipy.sparse.eye(adj_mat.shape[0]) * p + (adj_mat / adj_mat.sum(axis=1)) * (\n        1 - p\n    )  # transition probabilities matrix\n    M = scipy.sparse.csr_array(X.values) @ P\n    # https://en.wikipedia.org/wiki/Multinomial_distribution#Matrix_notation\n    R = scipy.sparse.diags(M.sum(axis=0)) - M.T @ M\n    return M.toarray(), R.toarray()\n\n\naugmentation_moments.append((kmeans_transformer.column_names(), geo_cluster_moments))\n\nLe’t fit the augmented model and see how we did:\n\naugmented_linear = AugmentedLinearModel(augmentation_moments)\nevaluate_model(augmented_linear)\n\nr2_train=0.903, r2_test=0.882\n\n\nWe managed to improve the test accuracy, and reduce overfit.\n\n\n\nIs it possible to extend the result to models that use a non-quadratic loss (e.g logistic regression)? Well the proof heavily relies on that, so probably not, but let’s if we can at least can an approximate result using a 2nd order taylor approximation for the loss.\nThe goal is to (approximately) express \\[\\begin{align*}\n    \\mathrm{E}  \n    \\left[\n    \\sum_{i=0} ^{n-1} l \\left(\n    a\\left(x_i, p_i\\right) ^T \\theta \\,;\\, y_i\n    \\right)\n    \\right],\n\\end{align*}\\] as a sum of a non-augmented loss term, and a regularization term. Here, \\(l(\\hat{y}\\,;\\,y)\\) measures how bad is the prediction \\(\\hat{y}\\), given the true value \\(y\\) (the loss).\nFor example, for logistic regression we use the logistic loss \\[\nl(\\hat{y}; y) = \\log \\left( 1 + \\exp \\left(-y \\, \\hat{y} \\right) \\right)\n\\] (with \\(y \\in \\{ -1, 1 \\}\\)).\nLet’s expand \\(l \\left(\na\\left(x_i, p_i\\right) ^T \\theta\\,;\\,y_i\n\\right)\\) around \\(\\mu_i ^T \\theta\\) and simplify: \\[\\begin{align*}\n\\mathrm{E}  \n\\left[\n\\sum_{i=0} ^{n-1} l \\left(\na\\left(x_i, p_i\\right) ^T \\theta \\,;\\, y_i\n\\right)\n\\right]\n\\approx\n\\sum_{i=0} ^{n-1} l(\\mu_i ^T \\theta\\,;\\,y_i) + \\frac{1}{2}  l'' \\left( \\mu_i ^T \\theta\\,;\\,y_i \\right) \\theta^T R \\theta\n\\end{align*}\\] (the order-1 term vanishes as it has zero mean, similar to the delta method).\nSo like in the least squares case, in the loss term we just replace each \\(x\\) with it’s mean. But, the regularization term is not quadratic, since we have the second derivative factor which is not constant (unless the loss is quadratic…).\nI use this result to tell myself that it is ok to select an \\(R\\) for a quadratic regularization based on the covariance of an augmentation, as long as the covariance is small (usually correct for augmentations), and \\(l''\\) is bounded (correct for logistic regression)."
  },
  {
    "objectID": "posts/augmentation_is_regularization/augmentation_is_regularization.html#notation",
    "href": "posts/augmentation_is_regularization/augmentation_is_regularization.html#notation",
    "title": "Augmentation is Regularization",
    "section": "",
    "text": "Suppose we have a training data set comprised of \\(n\\) pairs \\(x_i,\\,y_i\\) for \\(i=0, \\dots, n-1\\), where \\(x_i\\) is the \\(d\\) dimensional feature vector of the \\(i\\)’th training data, and \\(y_i\\) is the corresponding label. Here we will assume \\(y_i \\in \\mathrm{R}\\), however our results can be easily extended to the vector-labeled (aka multi-output) case. We will also denote by \\(X\\) the \\(n\\)-by-\\(d\\) matrix with rows \\(x_0^T, \\dots, x_{n-1}^T\\) and by \\(y\\) the \\(n\\)-vector with entries \\(y_0, \\dots, y_{n-1}\\).\nLet \\(a:\\mathrm{R}^d \\times \\mathcal{P}  \\mapsto \\mathrm{R}^d\\) denote the augmentation function that given the augmentation params \\(p \\in \\mathcal{P}\\), maps a feature vector \\(x\\) to a transformed feature vector. The augmentation parameters \\(p\\) are usually sampled randomly from a given distribution. For example, for image data, \\(a\\) is often a composition of small shifts, rotations, brightness changes, etc. while \\(p\\) specifies the amount of shifting, rotation and brightness change."
  },
  {
    "objectID": "posts/augmentation_is_regularization/augmentation_is_regularization.html#ordinary-least-squares-ols",
    "href": "posts/augmentation_is_regularization/augmentation_is_regularization.html#ordinary-least-squares-ols",
    "title": "Augmentation is Regularization",
    "section": "",
    "text": "Let’s quickly discuss OLS so we can compare it’s equations with the augmented version we will derive after.\nTo fit an OLS model, we find a vector of coefficients \\(\\theta_\\text{OLS}\\) that minimizes the sum of squared training errors: \\[\\begin{align*}\n    \\theta_\\text{OLS} &:= \\text{argmin} _\\theta \\sum_{i=0} ^{n-1} \\left(\n    x_i ^T \\theta - y_i\n    \\right) ^2\n    \\\\&= \\text{argmin} _\\theta \\| X \\theta - y \\|^2 \\tag{1}\n\\end{align*}\\] To solve the optimization problem (1), we solve the equation \\(X^TX \\theta_\\text{OLS} = X^T y\\), which has time complexity \\(O(n d^2)\\)."
  },
  {
    "objectID": "posts/augmentation_is_regularization/augmentation_is_regularization.html#augmented-least-squares",
    "href": "posts/augmentation_is_regularization/augmentation_is_regularization.html#augmented-least-squares",
    "title": "Augmentation is Regularization",
    "section": "",
    "text": "We will now fit a model by finding coefficients \\(\\theta_\\text{ALS}\\) that minimize the expected error over the augmented training dataset: \\[\\begin{align*}\n    \\theta_\\text{ALS} &:= \\text{argmin} _\\theta \\mathrm{E}  \n    \\left[\n    \\sum_{i=0} ^{n-1} \\left(\n    a\\left(x_i, p_i\\right) ^T \\theta - y_i\n    \\right) ^2\n    \\right], \\tag{2}\n\\end{align*}\\] where the expectation is over \\(p_0,\\dots, p_{n-1}\\), the random augmentation parameters. As we will see below, \\(\\theta_\\text{ALS}\\) depends on \\(a\\) and the distribution of \\(p\\) only through the 2nd order moments, which we denote by \\[\\begin{align*}\n    \\mu_i &:= \\mathrm{E} \\left[a(x_i, p_i) \\right]\\\\\n    R_i &:= \\mathrm{C}\\text{ov} \\left[ a(x_i, p_i) \\right].\n\\end{align*}\\]\nContinuing from (2), we use the standard trick of subtracting and adding the mean: \\[\\begin{align*}\n    \\theta_\\text{ALS} &= \\text{argmin} _\\theta \\mathrm{E}  \n    \\left[\n        \\sum_{i=0} ^{n-1} \\left(\n            \\left(\n                \\mu_i^T \\theta - y_i\n            \\right)\n            + \\left(\n                a\\left(x_i, p_i\\right) -\n                \\mu_i\n            \\right)^T\\theta\n        \\right) ^2\n    \\right]\n\\end{align*}\\] Note that the first term $ ( _i^T - y_i ) $ is deterministic, while the second term $ ( a(x_i, p_i) - _i )^T $ has zero mean. Therefore \\[\\begin{align*}\n    \\theta_\\text{ALS} &= \\text{argmin} _\\theta\n    \\sum_{i=0} ^{n-1}\n        \\left(\n            \\mu_i^T \\theta - y_i\n        \\right)\n        +\n        \\mathrm{E} \\left[\\left(\n            \\left(\n                a\\left(x_i, p_i\\right) -\n                \\mu_i\n            \\right)^T\\theta\n        \\right)^2 \\right] \\\\\n    &= \\text{argmin} _\\theta\n    \\| M \\theta - y\\|^2 + \\theta ^T R \\theta,\n    \\tag{3}\n\\end{align*}\\] where \\(M\\) is the \\(n\\)-by-\\(d\\) matrix whose rows are \\(\\mu_0^T, \\dots, \\mu_{n-1}^T\\), and \\[\nR := \\sum_{i=0} ^{n-1} R_i.\n\\] Equation (3) shows exactly what we set to prove - fitting a model on augmented training dataset, is equivalent to fitting a non-augmented, but quadratically regularized, least squares model. We just replace \\(X\\) with it’s mean, and use the sum of all covariances as the regularization matrix.\nTo solve the optimization problem (3), we solve the equation \\((X^T X + R) \\theta_\\text{ALS} = X^T y\\), which has the same \\(O(n d^2)\\) complexity as OLS."
  },
  {
    "objectID": "posts/augmentation_is_regularization/augmentation_is_regularization.html#ridge-regression",
    "href": "posts/augmentation_is_regularization/augmentation_is_regularization.html#ridge-regression",
    "title": "Augmentation is Regularization",
    "section": "",
    "text": "Ride regression (aka Tykhonov regularization) has the form (3) with \\(M=X\\) and \\(R=\\lambda I\\). As an augmentation, it can be interpreted as follows: perturb each feature vector by a zero mean noise, with variance \\(\\lambda/n\\), uncorrelated across features.\nThis interpretation of \\(\\lambda\\) can be used to set it (at least roughly): just think what level of perturbation \\(\\sigma\\) is reasonable for your features, and set \\(\\lambda = n \\sigma^2\\).\nThis also shows that when different feature are scaled differently, ridge regression is perhaps not the best fit. A standard deviation of 100 might be reasonable for a feature with values in the order of millions, but it is probably not suitable for a feature with values in the order of 1. In these cases, we may use a diagonal \\(R\\): \\[\\begin{align*}\n    R= n \\, \\text{diag} \\left(\n        \\sigma_0^2, \\dots, \\sigma_{d-1}^2\n    \\right)\n\\end{align*}\\] where \\(\\sigma_i\\) is the standard deviation of the perturbation of feature \\(i\\).\nAnother option is to scale the transformations before fit, e.g using sklearn’s StandardScaler. With all features scaled to have unit variance, setting \\(\\lambda = n \\, 10 ^{-6}\\) is a sensible rule of thumb, as it is often reasonable to assume a \\(0.1\\%\\) perturbation.\nNote that often the model includes an intercept (aka constant) term by adding a column of ones to \\(X\\). Since this column remain unchanged through any augmenting transformation, the corresponding row and column of \\(R\\) should be all zeros."
  },
  {
    "objectID": "posts/augmentation_is_regularization/augmentation_is_regularization.html#example",
    "href": "posts/augmentation_is_regularization/augmentation_is_regularization.html#example",
    "title": "Augmentation is Regularization",
    "section": "",
    "text": "For the example we are gonna use the House Sales in King County, USA dataset. Each row describes a house, sold between May 2014 and May 2015. Our goal will be to predict the log price given features like number of rooms, area, and geography.\nNote: several decisions outlined below weren’t necessarily the most effective,;, rather, they were chosen to showcase different modelling techniques in the context of augmentation via regularization.\nLet’s begin by importing everything we will need, loading our data, and adding some columns.\n\nfrom typing import Callable, Hashable, Self\n\nimport numpy as np\nfrom numpy.typing import NDArray\nimport pandas as pd\nimport scipy\nfrom sklearn.base import BaseEstimator\nfrom sklearn.cluster import KMeans\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.linear_model import LinearRegression, RidgeCV\nfrom sklearn.metrics import r2_score\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import StandardScaler\n\nArray = NDArray[np.float64]\n\ndf = pd.read_csv(\"data/kc_house_data.csv.zip\", parse_dates=[\"date\"])\ndf[\"long_scaled\"] = df[\"long\"] * np.mean(\n    np.abs(np.cos(df[\"lat\"] * np.pi / 180))\n)  # earth-curvature correction for (approximate) distance calculations\ndf.describe()\n\n\n\n\n\n\n\n\nid\ndate\nprice\nbedrooms\nbathrooms\nsqft_living\nsqft_lot\nfloors\nwaterfront\nview\n...\nsqft_above\nsqft_basement\nyr_built\nyr_renovated\nzipcode\nlat\nlong\nsqft_living15\nsqft_lot15\nlong_scaled\n\n\n\n\ncount\n2.161300e+04\n21613\n2.161300e+04\n21613.000000\n21613.000000\n21613.000000\n2.161300e+04\n21613.000000\n21613.000000\n21613.000000\n...\n21613.000000\n21613.000000\n21613.000000\n21613.000000\n21613.000000\n21613.000000\n21613.000000\n21613.000000\n21613.000000\n21613.000000\n\n\nmean\n4.580302e+09\n2014-10-29 04:38:01.959931648\n5.400881e+05\n3.370842\n2.114757\n2079.899736\n1.510697e+04\n1.494309\n0.007542\n0.234303\n...\n1788.390691\n291.509045\n1971.005136\n84.402258\n98077.939805\n47.560053\n-122.213896\n1986.552492\n12768.455652\n-82.471784\n\n\nmin\n1.000102e+06\n2014-05-02 00:00:00\n7.500000e+04\n0.000000\n0.000000\n290.000000\n5.200000e+02\n1.000000\n0.000000\n0.000000\n...\n290.000000\n0.000000\n1900.000000\n0.000000\n98001.000000\n47.155900\n-122.519000\n399.000000\n651.000000\n-82.677673\n\n\n25%\n2.123049e+09\n2014-07-22 00:00:00\n3.219500e+05\n3.000000\n1.750000\n1427.000000\n5.040000e+03\n1.000000\n0.000000\n0.000000\n...\n1190.000000\n0.000000\n1951.000000\n0.000000\n98033.000000\n47.471000\n-122.328000\n1490.000000\n5100.000000\n-82.548783\n\n\n50%\n3.904930e+09\n2014-10-16 00:00:00\n4.500000e+05\n3.000000\n2.250000\n1910.000000\n7.618000e+03\n1.500000\n0.000000\n0.000000\n...\n1560.000000\n0.000000\n1975.000000\n0.000000\n98065.000000\n47.571800\n-122.230000\n1840.000000\n7620.000000\n-82.482651\n\n\n75%\n7.308900e+09\n2015-02-17 00:00:00\n6.450000e+05\n4.000000\n2.500000\n2550.000000\n1.068800e+04\n2.000000\n0.000000\n0.000000\n...\n2210.000000\n560.000000\n1997.000000\n0.000000\n98118.000000\n47.678000\n-122.125000\n2360.000000\n10083.000000\n-82.411796\n\n\nmax\n9.900000e+09\n2015-05-27 00:00:00\n7.700000e+06\n33.000000\n8.000000\n13540.000000\n1.651359e+06\n3.500000\n1.000000\n4.000000\n...\n9410.000000\n4820.000000\n2015.000000\n2015.000000\n98199.000000\n47.777600\n-121.315000\n6210.000000\n871200.000000\n-81.865195\n\n\nstd\n2.876566e+09\nNaN\n3.671272e+05\n0.930062\n0.770163\n918.440897\n4.142051e+04\n0.539989\n0.086517\n0.766318\n...\n828.090978\n442.575043\n29.373411\n401.679240\n53.505026\n0.138564\n0.140828\n685.391304\n27304.179631\n0.095033\n\n\n\n\n8 rows × 22 columns\n\n\n\nWe will want a polynomial (rather than linear) dependency on the age of the house:\n\ndf[\"age\"] = df[\"date\"].dt.year - df[\"yr_built\"]\nage_cols = [\"age\"]\nfor power in range(2, 5):\n    col = f\"age ^ {power}\"\n    df[col] = df[\"age\"] ** power\n    age_cols.append(col)\n\nWe do a 10-90 train-test split to demonstrate the effectiveness of augmentation when we have little data.\n\ny = np.log(df[\"price\"])\nX = df.drop(columns=[\"price\"])\nx_train, x_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.9, random_state=42\n)\nprint(f\"{x_train.shape=}, {x_test.shape=}\")\n\nx_train.shape=(2161, 25), x_test.shape=(19452, 25)\n\n\nThere is no reason to expect a linear relationship between the house geographical coordinates and it’s price.\nHowever, we do expect a strong dependency between price and location in the sense that houses with similar features should share similar prices when located in close geographical proximity.\nOne way to model this is to cluster the data geographically, and tag each house with the cluster it belongs to using one hot encoding:\n\n# We need this class mainly since the transform method of sklearn's k-means class yields cluster centers, and we want one hot encoding.\nclass OneHotEncodedKMeansTransformer:\n    def __init__(self, k: int, columns: list[str], name: str) -&gt; None:\n        self.columns = columns\n        self.k = k\n        self.name = name\n\n    def fit(self, X: pd.DataFrame) -&gt; Self:\n        self.kmeans_ = KMeans(n_clusters=self.k, n_init=\"auto\", random_state=42)\n        self.kmeans_.fit(X[self.columns])\n        return self\n\n    def column_names(self) -&gt; list[str]:\n        return [f\"{self.name}_{i}\" for i in range(self.k)]\n\n    def transform(self, X: pd.DataFrame):\n        cluster_index = self.kmeans_.predict(X[self.columns])\n        return pd.concat(\n            [\n                X,\n                pd.DataFrame(\n                    np.eye(self.k)[cluster_index],\n                    columns=self.column_names(),\n                    index=X.index,\n                ),\n            ],\n            axis=1,\n        )\n\n    def clusters_adjacency_matrix(self):\n        edges = np.array(\n            scipy.spatial.Voronoi(self.kmeans_.cluster_centers_).ridge_points\n        ).T\n        a = scipy.sparse.coo_matrix(\n            (np.ones(edges.shape[1]), (edges[0], edges[1])),\n            shape=(self.k, self.k),\n        )\n        return a + a.T\n\n\nkmeans_transformer = OneHotEncodedKMeansTransformer(\n    k=500,\n    columns=[\"lat\", \"long_scaled\"],\n    name=\"geo_cluster\",\n)\nx_train = kmeans_transformer.fit(x_train).transform(x_train)\nx_test = kmeans_transformer.transform(x_test)\n\nWe will evaluate our models by their R squared score. From a quick glance over Kaggle, it seems that sophisticated and advanced models (e.g XGBoost) can achieve a score of about 0.9. Let’s see if we can get there using a linear model.\n\ndef evaluate_model(model) -&gt; None:\n    y_train_pred = model.fit(x_train, y_train).predict(x_train)\n    r2_train = r2_score(y_train, y_train_pred)\n    y_test_pred = model.predict(x_test)\n    r2_test = r2_score(y_test, y_test_pred)\n    print(f\"{r2_train=:.3f}, {r2_test=:.3f}\")\n\nLet’s start with a vanilla linear model, without any regularization/augmentations.\n\ncolumns = (\n    [\n        \"bedrooms\",\n        \"bathrooms\",\n        \"floors\",\n        \"waterfront\",\n        \"view\",\n        \"condition\",\n        \"grade\",\n        \"sqft_living\",\n        \"sqft_lot\",\n        \"sqft_above\",\n        \"sqft_basement\",\n        \"sqft_lot15\",\n        \"sqft_living15\",\n    ]\n    + age_cols\n    + kmeans_transformer.column_names()\n)\ncolumns_selector = ColumnTransformer(\n    [(\"selector\", \"passthrough\", columns)],\n    remainder=\"drop\",\n    verbose_feature_names_out=False,\n).set_output(transform=\"pandas\")\n\nsimple_linear = Pipeline(\n    [\n        (\"selector\", columns_selector),\n        (\"linear\", LinearRegression(fit_intercept=False)),\n    ]\n)\nevaluate_model(simple_linear)\n\nr2_train=0.918, r2_test=0.862\n\n\nNot bad, but we do have some overfitting. Let’s see if we can improve generalization with regularization/augmentation. First we try ridge regression:\n\nridge = Pipeline(\n    [\n        (\"selector\", columns_selector),\n        (\"scale\", StandardScaler()),\n        (\n            \"linear\",\n            RidgeCV(\n                fit_intercept=True,\n                alphas=x_train.shape[0] * np.logspace(-9, -2, 100),\n            ),\n        ),\n    ]\n)\nevaluate_model(ridge)\n\nr2_train=0.918, r2_test=0.863\n\n\nThat didn’t really help. That makes sense since using a diagonal regularization matrix doesn’t make sense for our correlated features.\nLet’s see if we can do better by using augmentations that are more appropriate for our data.\nFirst let’s build a class for linear models with augmentation via regularization.\nWe will pass to the constructor a callable that takes the input features and returns their mean and (sum of) covariance after the augmentation, since as we shown above these are all we need from the augmentations.\nSince often the transformations of different features are uncorrelated, it is convenient to specify features in groups, and assume zero covariance for features that are not in the same group (i.e a block diagonal covariance matrix).\n\nclass AugmentedLinearModel:\n    def __init__(\n        self,\n        augmentation_moments: list[  # one item for each group of features\n            tuple[\n                list[Hashable],  # column names of features in the group\n                Callable[[pd.DataFrame], tuple[Array, Array]],  # maps X to M and R\n            ]\n        ],\n    ) -&gt; None:\n        self.augmentation_moments = augmentation_moments\n\n    def fit(self, X: pd.DataFrame, y: pd.Series) -&gt; Self:\n        means, covs = zip(\n            *(\n                moments(X.loc[:, columns])\n                for columns, moments in self.augmentation_moments\n            )\n        )\n        M = np.hstack(means)\n        # https://scikit-learn.org/stable/developers/develop.html#estimated-attributes\n        self.R_ = scipy.linalg.block_diag(*covs)\n        self.theta_ = np.linalg.solve(M.T @ M + self.R_, M.T @ y)\n        return self\n\n    def predict(self, X: pd.DataFrame) -&gt; pd.Series:\n        cols = [col for cols, _ in self.augmentation_moments for col in cols]\n        return X.loc[:, cols] @ self.theta_\n\nHere are the augmentations we are gonna use:\nWith 10% probability, a bathroom is counted as half a bedroom.\n\ndef bedrooms_bathrooms_moments(X: pd.DataFrame) -&gt; tuple[Array, Array]:\n    p = 0.1\n    v = np.array([1, -0.5])\n    mask = X[[\"bathrooms\"]] &gt;= 1\n    M = np.where(mask, X + p * v, X)\n    R = p * (1 - p) * np.outer(v, v) * mask.values.sum()\n    return M, R\n\n\naugmentation_moments = [([\"bedrooms\", \"bathrooms\"], bedrooms_bathrooms_moments)]\n\nA 5% perturbation for the features\nsqft_living, sqft_lot, sqft_above, sqft_basement, sqft_lot15, sqft_living15, uncorrelated across the features.\n\ndef relative_perturbation_moments(X: pd.DataFrame) -&gt; tuple[Array, Array]:\n    return X.values, np.sum(X.values**2) * 0.05**2\n\n\naugmentation_moments.extend(\n    ([column], relative_perturbation_moments)\n    for column in [\n        \"sqft_living\",\n        \"sqft_lot\",\n        \"sqft_above\",\n        \"sqft_basement\",\n        \"sqft_lot15\",\n        \"sqft_living15\",\n    ]\n)\n\nA perturbation of 0.01 for the features floors, waterfront, view, condition, grade, uncorrelated across the features\n\ndef absolute_perturbation_moments(X: pd.DataFrame) -&gt; tuple[Array, Array]:\n    return X.values, X.shape[0] * 0.01**2\n\n\naugmentation_moments.extend(\n    ([column], absolute_perturbation_moments)\n    for column in [\"floors\", \"waterfront\", \"view\", \"condition\", \"grade\"]\n)\n\nperturbing age with a uniform distribution between -1 and 1. We need to calculate the moments for the power of age accordingly.\n\ndef age_moments(X: pd.DataFrame) -&gt; tuple[Array, Array]:\n    a = X[[\"age\"]].values - 1\n    b = X[[\"age\"]].values + 1\n    max_power = X.shape[1]\n    np1 = np.arange(2, 2 * max_power + 2)\n    # https://en.wikipedia.org/wiki/Continuous_uniform_distribution#Moments\n    mu = (b**np1 - a**np1) / (np1 * (b - a))\n    mu_sum = mu[:, 1:].sum(axis=0)\n    mu = mu[:, :max_power]\n    idx = np.add.outer(np.arange(max_power), np.arange(max_power))\n    c = mu_sum[idx] - mu.T @ mu\n    return mu, c\n\n\naugmentation_moments.append((age_cols, age_moments))\n\nAnd finally, with probability 50%, the geo cluster is changed to one of it’s neighbors.\n\ndef geo_cluster_moments(X: pd.DataFrame) -&gt; tuple[Array, Array]:\n    p = 0.5\n    adj_mat = kmeans_transformer.clusters_adjacency_matrix()\n    P = scipy.sparse.eye(adj_mat.shape[0]) * p + (adj_mat / adj_mat.sum(axis=1)) * (\n        1 - p\n    )  # transition probabilities matrix\n    M = scipy.sparse.csr_array(X.values) @ P\n    # https://en.wikipedia.org/wiki/Multinomial_distribution#Matrix_notation\n    R = scipy.sparse.diags(M.sum(axis=0)) - M.T @ M\n    return M.toarray(), R.toarray()\n\n\naugmentation_moments.append((kmeans_transformer.column_names(), geo_cluster_moments))\n\nLe’t fit the augmented model and see how we did:\n\naugmented_linear = AugmentedLinearModel(augmentation_moments)\nevaluate_model(augmented_linear)\n\nr2_train=0.903, r2_test=0.882\n\n\nWe managed to improve the test accuracy, and reduce overfit."
  },
  {
    "objectID": "posts/augmentation_is_regularization/augmentation_is_regularization.html#beyond-least-squares",
    "href": "posts/augmentation_is_regularization/augmentation_is_regularization.html#beyond-least-squares",
    "title": "Augmentation is Regularization",
    "section": "",
    "text": "Is it possible to extend the result to models that use a non-quadratic loss (e.g logistic regression)? Well the proof heavily relies on that, so probably not, but let’s if we can at least can an approximate result using a 2nd order taylor approximation for the loss.\nThe goal is to (approximately) express \\[\\begin{align*}\n    \\mathrm{E}  \n    \\left[\n    \\sum_{i=0} ^{n-1} l \\left(\n    a\\left(x_i, p_i\\right) ^T \\theta \\,;\\, y_i\n    \\right)\n    \\right],\n\\end{align*}\\] as a sum of a non-augmented loss term, and a regularization term. Here, \\(l(\\hat{y}\\,;\\,y)\\) measures how bad is the prediction \\(\\hat{y}\\), given the true value \\(y\\) (the loss).\nFor example, for logistic regression we use the logistic loss \\[\nl(\\hat{y}; y) = \\log \\left( 1 + \\exp \\left(-y \\, \\hat{y} \\right) \\right)\n\\] (with \\(y \\in \\{ -1, 1 \\}\\)).\nLet’s expand \\(l \\left(\na\\left(x_i, p_i\\right) ^T \\theta\\,;\\,y_i\n\\right)\\) around \\(\\mu_i ^T \\theta\\) and simplify: \\[\\begin{align*}\n\\mathrm{E}  \n\\left[\n\\sum_{i=0} ^{n-1} l \\left(\na\\left(x_i, p_i\\right) ^T \\theta \\,;\\, y_i\n\\right)\n\\right]\n\\approx\n\\sum_{i=0} ^{n-1} l(\\mu_i ^T \\theta\\,;\\,y_i) + \\frac{1}{2}  l'' \\left( \\mu_i ^T \\theta\\,;\\,y_i \\right) \\theta^T R \\theta\n\\end{align*}\\] (the order-1 term vanishes as it has zero mean, similar to the delta method).\nSo like in the least squares case, in the loss term we just replace each \\(x\\) with it’s mean. But, the regularization term is not quadratic, since we have the second derivative factor which is not constant (unless the loss is quadratic…).\nI use this result to tell myself that it is ok to select an \\(R\\) for a quadratic regularization based on the covariance of an augmentation, as long as the covariance is small (usually correct for augmentations), and \\(l''\\) is bounded (correct for logistic regression)."
  },
  {
    "objectID": "posts/pearson_correlation/pearson_correlation.html",
    "href": "posts/pearson_correlation/pearson_correlation.html",
    "title": "A practical interpertation of the Pearson correlation coefficient",
    "section": "",
    "text": "\\[\n\\renewcommand{\\E}[1]{\\operatorname{E}\\left[#1\\right]}\n\\renewcommand{\\var}[1]{\\operatorname{Var} \\left[#1 \\right]}\n\\renewcommand{\\cov}[1]{\\operatorname{Cov} \\left[#1 \\right] }\n\\] My goal is to explain the Pearson correlation coefficient without using the word correlation, which is often used to describe it.\nThe Pearson correlation coefficient of two random variables \\(X\\) and \\(Y\\) is \\[\n\\rho := \\frac{\\sigma_{XY}}{\\sigma_X \\sigma_Y},\n\\] where \\(\\sigma_X, \\sigma_Y\\) are the standard deviation of \\(X\\) and \\(Y\\), and \\(\\sigma_{XY}\\) is their covariance.\nA motivation for the definition \\(\\rho\\) comes from the problem of estimating \\(Y\\) from an observation of \\(X\\). It turns out that in the optimal (lowest MSE) linear estimation, the number of standard deviations \\(Y\\) is above it’s mean is \\(\\rho\\) times the number of standard deviations \\(X\\) is above it’s mean.\nFor example, consider a population of people where height and weight are correlated with \\(\\rho=0.72\\), heights are distributed with mean \\(170\\)cm and a standard deviation of \\(10\\)cm, weights are distributed with mean \\(70\\)Kg and a standard deviation of \\(20\\)Kg. If you know that the height of a certain person is \\(190\\)cm, a good guess for it’s weight is \\(70 + 2 \\cdot 0.72 \\cdot 20 = 98.8\\)Kg.\nThe proof is very simple. Since we are dealing with linear (actually, affine) estimators, we need to show that the \\(a\\) and \\(b\\) that would minimize \\[\n\\text{MSE} := \\E{ \\left( \\hat{Y} - Y \\right) ^2},\n\\] where \\(\\hat{Y} := a (X - \\mu_x) + b\\), are \\(\\rho \\sigma_Y / \\sigma_X\\) and \\(\\mu_Y\\).\nThe MSE is the sum of bias squared and variance. The variance doesn’t depend on \\(b\\), and the bias is \\(\\E{  \\hat{Y} - Y } = b - \\mu_Y\\) which doesn’t depend on \\(a\\). so \\(b=\\mu_Y\\). To minimize the variance, we simplify \\[\n\\begin{align*}\n\\var{\\hat{Y} - Y}\n&= \\var{\\hat{Y}} + \\var{Y} - 2 \\cov{\\hat{Y}, Y}\n\\\\&= \\sigma_x ^ 2 a^2\n   + \\sigma_Y ^2\n   -2  \\sigma_{XY} a\n\\end{align*}\n\\] This is just a parabola in \\(a\\), so the optimal \\(a\\) is \\[\na=\\frac{2 \\sigma_{XY}} {2 \\sigma_X ^2}\n=\n\\rho \\frac{\\sigma_Y } {\\sigma_X }\n\\] (which is what we wanted to show).\nThe estimator is unbiased, so it’s MSE is equal to it’s variance: \\[\n\\text{MSE} = \\sigma_Y ^2 (1 - \\rho ^ 2).\n\\] This equation gives another concrete interpretation of \\(\\rho\\): If \\(X\\) and \\(Y\\) are correlated with coefficient \\(\\rho\\), observing \\(X\\) will decrease the standard deviation of a \\(Y\\) estimate by a factor of at least \\(\\sqrt{1 - \\rho^2}\\).\n“at least” since the the optimal linear estimator is equal or worse than the optimal estimator.\nIn the example above, knowing the height decreases weight estimation standard deviation from 20Kg to \\(20  (1 - 0.72^2) = 9.6\\)Kg.\nRandomly ordered notes:\n\nIf \\(X\\) and \\(Y\\) are jointly Gaussian, the optimal linear estimator is also the optimal estimator.\nThe “mean” in “MSE” is an average over the joint distribution of \\(X\\) and \\(Y\\), which is different than over the distribution of \\(Y\\) given \\(X\\), for which our estimator is not the optimal linear estimator (and biased).\nIn our example, we estimated the weight to be \\(98.8\\)Kg with variance \\(9.6^2\\). It doesn’t mean that if we will sample random people with height \\(190\\)cm, we would get a mean weight of \\(98.8\\)Kg and variance smaller than \\(9.6^2\\). It means that if we sample random people, and estimate their weight from their height using the optimal linear estimator, our error will be zero on average, and with variance \\(9.6^2\\). If we use the optimal estimator, the \\(9.6^2\\) is an upper bound on the variance.\nThe sentence “\\(X\\) and \\(Y\\) are not correlated” now has a concrete meaning: it means that the optimal linear estimator of \\(Y\\) from \\(X\\) will be the mean of \\(Y\\), ignoring \\(X\\) completely.\nThe discussion above is “Bayesian”, in the sense that it assumes you have some knowledge about the distribution of \\(X\\) and \\(Y\\). In practice we usually get \\(n\\) samples of \\(X\\) and \\(Y\\) pairs, and we use plug-in estimators to estimate the means, variances, and covariance, which we will then use build our \\(Y\\) from \\(X\\) linear estimator.\nMachine learning people would say: we can use the samples to train a linear regression model to predict \\(Y\\) from \\(X\\) directly. Sounds better, more “end-to-end”y, but actually it gives exactly the same result (assuming we don’t use Bessel’s correction).\nProof:\nWe denote by \\(x\\) and \\(y\\) be the vectors of samples of \\(X\\) and \\(Y\\), by \\(\\mathbf{1}\\) a vector of ones, and by \\(A\\) the matrix whose first column is \\(x\\) and the second column is \\(\\mathbf{1}\\). The coefficients of the linear model are given by: \\[\n\\begin{align*}\n\\begin{bmatrix}\n     \\theta_{\\text{slope}} \\\\\n     \\theta_{\\text{intercept}}\n\\end{bmatrix}\n&:=\n\\text{argmin}_\\theta \\| A \\theta - y \\|^2\n\\\\&=\n\\left( A ^T A \\right)^{-1} A^T y\n\\\\&=\n\\begin{bmatrix}\n     \\|x\\|^2 && \\mathbf{1}^Tx \\\\\n     \\mathbf{1}^T x  && \\mathbf{1}^T \\mathbf{1}\n\\end{bmatrix}\n^{-1}\n\\begin{bmatrix}\n     x^T y \\\\\n     \\mathbf{1} ^T y\n\\end{bmatrix}\n\\\\&=\n\\begin{bmatrix}\n     \\sigma_X^2 + \\mu_X^2 && \\mu_X \\\\\n     \\mu_X  && 1\n\\end{bmatrix}\n^{-1}\n\\begin{bmatrix}\n     \\sigma_{XY} + \\mu_X \\mu_Y \\\\\n     \\mu_Y\n\\end{bmatrix}\n\\\\&=\n\\frac{1}{\\sigma_X ^2}\n\\begin{bmatrix}\n     1 && -\\mu_X \\\\\n     -\\mu_X  && \\sigma_X^2 + \\mu_X^2\n\\end{bmatrix}\n\\begin{bmatrix}\n     \\sigma_{XY} + \\mu_X \\mu_Y \\\\\n     \\mu_Y\n\\end{bmatrix}\n\\\\&=\n\\frac{1}{\\sigma_X ^2}\n\\begin{bmatrix}\n     \\sigma_{XY} \\\\\n     -\\mu_X \\sigma_{XY} + \\sigma_X^2 \\mu_Y\n\\end{bmatrix}\n\\\\&=\n\\begin{bmatrix}\n     a \\\\\n     -\\mu_X a + b\n\\end{bmatrix}.\n\\end{align*}\n\\] Note also that the r2-score of this fit is equal to \\(\\rho^2\\): \\[\nr^2 := 1 - \\frac{\\text{MSE}}{\\sigma_Y^2} = 1 - \\frac{\\sigma_Y ^2 \\left(1-\\rho^2\\right)}{\\sigma_Y ^2} = \\rho^2.\n\\]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "MUSIC as a sparse decomposition method\n\n\n\n\n\nA unique introduction to the MUSIC algorithm, as a general method to solve the multisnapshot sparse decomposition problem.\n\n\n\n\n\nJan 30, 2024\n\n\nTom Shlomo\n\n\n\n\n\n\n\n\n\n\n\n\nA practical interpertation of the Pearson correlation coefficient\n\n\n\n\n\n\\(\\rho=1\\) means perfect positive correlation, \\(\\rho=-1\\) means perfect negative correlation, \\(\\rho=0\\) means no correlation. But what does \\(\\rho=0.72\\) mean?\n\n\n\n\n\nJan 20, 2024\n\n\nTom Shlomo\n\n\n\n\n\n\n\n\n\n\n\n\nAugmentation is Regularization\n\n\n\n\n\nOn the equivalence of training data augmentation and quadratic regularization for linear models - a very useful (but not well known) result.\n\n\n\n\n\nJan 15, 2024\n\n\nTom Shlomo\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/music/music.html",
    "href": "posts/music/music.html",
    "title": "MUSIC as a sparse decomposition method",
    "section": "",
    "text": "MUSIC (MUltiple SIgnal Classification) is a popular algorithm used to estimating the directions of arrival (DOA) of waves recorded by an array of sensors.\nWhile very useful for this task, MUSIC is actually a more general parameters estimation method. However, conventional introductions to MUSIC often delve into the intricacies of equations tailored specifically for DOA estimation. These equations, laden with complex exponents or trigonometric identities, not only risk overwhelming readers but also obscure the fundamental insights that form the backbone of the method.\nAn assumption most derivations of MUSIC rely on is access to the signals autocorrelation matrix. In practice, only it’s estimate is available (usually from very few samples), and in many cases the signals are not stationary (e.g. speech) so it is not even well defined. Furthermore, most derivations of the algorithm rely on the noise being white, which is often not realistic.\nNevertheless, MUSIC can perform extremely well even when all these assumptions do not hold, which implies the existence of an alternative derivation. In this post I want to address the issues above by introducing MUSIC as a general method to (approximately) solve the multi-snapshot sparse decomposition problem."
  },
  {
    "objectID": "posts/music/music.html#a-quick-introduction-to-sparse-decompositions",
    "href": "posts/music/music.html#a-quick-introduction-to-sparse-decompositions",
    "title": "MUSIC as a sparse decomposition method",
    "section": "A quick introduction to sparse decompositions",
    "text": "A quick introduction to sparse decompositions\nYou obtained an \\(n\\)-dimensional vector \\(y\\), and you know that it is a linear combination of several “atoms”. You don’t know which atoms, but you do know that they come from a given set of atoms \\(a_1, \\dots, a_m\\) known as the dictionary. The goal is to decompose \\(y\\) to it’s atoms, that is, find the atoms that participate in the linear combination. In matrix notation: \\[\ny = Ax\n\\] where \\(A\\) is the (known) dictionary matrix, with columns \\(a_1, \\dots, a_m\\), and \\(x\\) contains the (unknown) coefficient for each atom. The non-zero indices of \\(x\\) correspond to the atoms that participate in the linear combination.\nIt might be tempting to simply solve for \\(x\\) as both \\(A\\) and \\(y\\) are known, but (at least for the interesting cases) \\(m &gt; n\\) and the system is under determined, that is, there are infinite ways to decompose \\(y\\) to a linear combination of atoms.\nIn the setting of sparse decompositions, we add an additional prior to the problem: \\(y\\) is composed of at most \\(k &lt; m\\) atoms, which means \\(x\\) is \\(k\\)-sparse (has at most \\(k\\) non zeros). The indices of the non-zeros entries of \\(x\\) are called the support of \\(x\\).\nFor example, in DOA estimation problems, we can use \\(y\\) to represent a signal recorded by an array of sensors at different locations, \\(a_i\\) is the response of the array to a unit amplitude signal coming from the \\(i\\)’th direction, and \\(x_i\\) the amplitude of the signal at the \\(i\\)’th direction. Assuming \\(x\\) is \\(k\\)-sparse is the same as assuming there are at most \\(k\\) signals active simultaneously. Decomposing \\(y\\) into it’s atoms reveals the directions of the recorded signals.\nThere are 2 important extensions to the basic sparse decomposition problem. The first is increasing robustness to noise or modeling errors, by looking for an approximate sparse decomposition instead of an exact one.\nFor example, in machine learning, sparse decomposition can be used for automatic feature selection in linear regression problems. Here \\(y\\) contains the training data labels, \\(A\\) contains the training data features, \\(x\\) is the coefficient of each feature, and \\(k\\) is the number of features to select.\nThe second extension is the joint sparsity problem (aka multi-snapshot), where instead of having a single vector \\(y\\), we get \\(p\\) vectors \\(y_1, \\dots, y_p\\). In matrix notation: \\[\nY = AX\n\\] where \\[\\begin{align*}\n    Y &:= \\begin{bmatrix} y_1 && \\cdots && y_p \\end{bmatrix}\n\\end{align*}\\] is the data matrix, and \\(X_{ij}\\) is the (unknown) coefficient of atom \\(a_i\\) in \\(y_j\\). Here, not only the columns of \\(X\\) are \\(k\\)-sparse, they also share the same support. This means that the matrix \\(X\\) is \\(k\\)-row-sparse, that is, has up to \\(k\\) non-zero rows.\nIn the direction of arrival estimation example, the joint sparsity problem can be obtained by observing the signals at \\(p\\) different (usually consecutive) times.\nIn the feature selection for linear regression example, the joint sparsity problem is obtained when we have multiple labels to predict, and we want to select the same \\(k\\) feature for each.\nSolving sparse decomposition problems is in general a hard problem. It turns out that you can’t do much better than enumerating over all \\(m \\choose k\\) possibilities for the support. Popular methods that yield approximate solutions are Matching Pursuit, Orthogonal Matching Pursuit, Basis Pursuit, and LASSO. In some cases, under additional assumptions, we can get some guarantees that the solution is exact, or close to exact. Although usually not presented as such, MUSIC is also a sparse decomposition method for the joint sparsity case, that under additional assumptions can provide exactness guarantees.\nWe will start by describing a method that can, under several assumptions, efficiently solve the noiseless joint sparsity problem. As we will see below, MUSIC can be viewed as an extension of this method for the noisy case.\nLet \\(S\\) denote the (unknown) support of \\(X\\). We will denote by \\(X_S\\) the matrix obtained by keeping only the rows in \\(S\\), and by \\(A_S\\) the matrix obtained by keeping only the columns in \\(S\\). Note that with this notation, we have \\[\nY = AX = A_S X_S.\n\\]\nMUSIC is based 2 assumptions:\nOur goal is to find \\(S\\) from \\(Y\\). Assumption 2 implies that \\[\n\\text{Range}(Y)\n=\n\\text{Range}(A_S X_S)\n=\n\\text{Range}(A_S),\n\\] so we can get \\(\\text{Range}(A_S)\\) from \\(Y\\). Assumption 2 means that once we have \\(\\text{Range}(A_s)\\), we can reconstruct \\(S\\) simply by checking which atoms are in it. The implied algorithm is simple:\nAlthough correct and efficient, this is a terrible algorithm. Calculating the range of a matrix is numerically unstable, and even the slightest perturbation (e.g. a roundoff error) can change it drastically. But before we continue to the more noise-robust MUSIC, let’s discuss the implications of the 2 assumptions.\nAssumption 1 means that to build an atom from a linear combination of other atoms, you need more than \\(\\left| S \\right|\\) atoms. This is related to something called the spark of \\(A\\). We won’t get into it here, but condition on the dictionary spark are elementary in basically every sparse decomposition method. For certain dictionaries, it can be shown that assumption 1 holds for any \\(S\\) of size less than \\(n\\). Specifically, this holds for the dictionary in DOA estimation problems with linear, equally spaced array of sensors, if the usual anti-aliasing conditions hold: the spacing between the sensors is smaller than half the wavelength, and no 2 directions lie on the same cone who’s axis contains the array.\nAssumption 2 is more restrictive. It means that no row of \\(X_S\\) is a linear combination of the other rows. A necessary (but not sufficient) condition is \\(\\left| S \\right| \\leq p\\). In the DOA estimation problem, each rows of \\(X_S\\) contains the samples of a different source. If the sources are uncorrelated (e.g. different speakers) and \\(\\left| S \\right| \\leq p\\), it is very unlikely that one is a linear combination of the others. If the sources are correlated, this doesn’t hold, and MUSIC can not be applied. This happens, for example, when one source is an echo of another, due to multi-path propagation.\nThe method above relies on the equation \\(\\text{Range}(Y) = \\text{Range}(A_S)\\) which is true if \\(Y=AX\\). However, in real life, the best we can hope for is \\(Y=AX+W\\), where \\(W\\), the noise term, is very small compared to \\(AX\\). Unfortunately, no matter how small \\(W\\) is, due to the discontinuity of \\(\\text{Range}\\), it won’t even hold approximately. In fact, if \\(p \\geq n\\), we will almost surely have \\(\\text{Range}(Y) = \\reals ^n\\), and the algorithm above would just yield \\(S=\\left\\{1, \\dots,  m \\right\\}\\).\nMUSIC makes 2 modifications the the algorithm above.\nFirst, we replace \\(Y\\) with \\(\\tilde{Y}\\), a rank-\\(\\left| S \\right|\\) approximation of \\(Y\\).\nNote that this requires us to know \\(\\left| S \\right|\\). This is another assumption MUSIC makes (although it can be avoided, sometimes, using model selection methods).\nSince \\(AX\\) has rank \\(\\left| S \\right|\\), taking a rank \\(\\left| S \\right|\\) approximation has a denoising effect. Indeed, unlike \\(\\text{Range} \\left( Y \\right)\\), \\(\\text{Range} \\left( \\tilde{Y} \\right)\\) is a good estimate for \\(\\text{Range} \\left( A_S \\right)\\) when \\(W\\) is small, but it is not exact: almost surely, none of the atoms would lie exactly in it. So the second modification is to soften our requirement that \\(a_i \\in \\text{Range} \\left( \\tilde{Y} \\right)\\) to add \\(i\\) to \\(S\\). Instead, we will require that \\(a_i\\) is almost in \\(\\text{Range} \\left( \\tilde{Y} \\right)\\), by checking if it looses little magnitude when projected onto it: \\[\nc_i := \\frac{\\| \\text{Proj}_{\\text{Range} \\left( \\tilde{Y} \\right)}(a_i) \\|^2}\n{\\| a_i \\|^2 }\n\\text{ is close to 1}\n\\implies\n\\text{ add $i$ to $S$}\n\\] (what “is close” means exactly differs between implementations. When the atoms can be ordered, like in DOA estimation, it is common to use a peak selection algorithm).\nAs we said above, \\(\\tilde{Y}\\) is a rank-\\(\\left| S \\right|\\) approximation to \\(Y\\). In MUSIC, we use the best rank-\\(\\left| S \\right|\\) approximation in the least squares sense, which is given by the truncated singular value decomposition (SVD) of \\(Y\\). Note that we don’t really need to calculate \\(\\tilde{Y}\\) itself, all we really need is the projection to it’s range. Well, a nice about the SVD is that we can get it directly: \\[\n\\label{music_final}\nc_i = \\frac{\\| U^T a_i\\|^2}{\\| a_i\\|^2}.\n\\] where the columns of \\(U\\) are the first \\(\\left| S \\right|\\) left singular vectors (which form an orthonormal basis for \\(\\text{Range} \\left( \\tilde{Y} \\right)\\)).\nTo wrap things up, a few notes to connect the above to the “usual” MUSIC derivation:"
  },
  {
    "objectID": "posts/music/music.html#footnotes",
    "href": "posts/music/music.html#footnotes",
    "title": "MUSIC as a sparse decomposition method",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWith linear, equally spaced array of sensors, if the usual anti-aliasing conditions hold: the spacing between the sensors is smaller than half the wavelength, and no 2 directions lie on the same cone who’s axis contains the array.↩︎\n\\(\\text{Range} \\left( A_S \\right)\\) is sometimes called the signal subspace, and the subspace orthogonal to it the noise subspace.↩︎"
  },
  {
    "objectID": "posts/music/music.html#music",
    "href": "posts/music/music.html#music",
    "title": "MUSIC as a sparse decomposition method",
    "section": "MUSIC",
    "text": "MUSIC\nThe method above relies on the equation \\(\\text{Range}(Y) = \\text{Range}(A_S)\\) which is true if \\(Y=AX\\). However, in real life, the best we can hope for is \\(Y=AX+W\\), where \\(W\\), the noise term, is very small compared to \\(AX\\). Unfortunately, no matter how small \\(W\\) is, due to the discontinuity of \\(\\text{Range}\\), it won’t even hold approximately. In fact, if \\(p \\geq n\\), we will almost surely have \\(\\text{Range}(Y) = \\reals ^n\\), and the algorithm above would just yield \\(S=\\left\\{1, \\dots,  m \\right\\}\\).\nMUSIC makes 2 modifications the the algorithm above.\nFirst, we replace \\(Y\\) with \\(\\tilde{Y}\\), a rank-\\(\\left| S \\right|\\) approximation of \\(Y\\).\nNote that this requires us to know \\(\\left| S \\right|\\). This is another assumption MUSIC makes (although it can be avoided, sometimes, using model selection methods).\nSince \\(AX\\) has rank \\(\\left| S \\right|\\), taking a rank \\(\\left| S \\right|\\) approximation has a denoising effect. Indeed, unlike \\(\\text{Range} \\left( Y \\right)\\), \\(\\text{Range} \\left( \\tilde{Y} \\right)\\) is a good estimate for \\(\\text{Range} \\left( A_S \\right)\\) when \\(W\\) is small, but it is not exact: almost surely, none of the atoms would lie exactly in it. So the second modification is to soften our requirement that \\(a_i \\in \\text{Range} \\left( \\tilde{Y} \\right)\\) to add \\(i\\) to \\(S\\). Instead, we will require that \\(a_i\\) is almost in \\(\\text{Range} \\left( \\tilde{Y} \\right)\\), by checking if it looses little magnitude when projected onto it: \\[\nc_i := \\frac{\\| \\text{Proj}_{\\text{Range} \\left( \\tilde{Y} \\right)}(a_i) \\|^2}\n{\\| a_i \\|^2 }\n\\text{ is close to 1}\n\\implies\n\\text{ add $i$ to $S$}\n\\] (what “is close” means exactly differs between implementations. When the atoms can be ordered, like in DOA estimation, it is common to use a peak selection algorithm).\nAs we said above, \\(\\tilde{Y}\\) is a rank-\\(\\left| S \\right|\\) approximation to \\(Y\\). In MUSIC, we use the best rank-\\(\\left| S \\right|\\) approximation in the least squares sense, which is given by the truncated singular value decomposition (SVD) of \\(Y\\). Note that we don’t really need to calculate \\(\\tilde{Y}\\) itself, all we really need is the projection to it’s range. Well, a nice about the SVD is that we can get it directly: \\[\n\\label{music_final}\nc_i = \\frac{\\| U^T a_i\\|^2}{\\| a_i\\|^2}.\n\\] where the columns of \\(U\\) are the first \\(\\left| S \\right|\\) left singular vectors (which form an orthonormal basis for \\(\\text{Range} \\left( \\tilde{Y} \\right)\\)).\nTo wrap things up, a few notes to connect the above to the “usual” MUSIC derivation:"
  }
]