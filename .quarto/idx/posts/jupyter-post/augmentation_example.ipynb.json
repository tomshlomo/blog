{"title":"Augmentation is Regularization","markdown":{"yaml":{"title":"Augmentation is Regularization","author":"Tom Shlomo","date":"2024-01-15","categories":["machine learning","regularization"],"description":"On the equivalence of training data augmentation and quadratic regularization for linear models - a very useful (but not well known) result."},"headingText":"Augmentation is Regularization","containsRefs":false,"markdown":"\n\nTraining data augmentation enhances the training dataset by applying transformations to existing training data instances. \nThe specific transformations vary depending on the type of data involved, and this flexibility allows to leverage domain knowledge, such as known invariants, effectively.\nThe goal is to introduce variability and increase the diversity of the training set, allowing the model to better generalize to unseen data and exhibit improved robustness.\nDespite the advantages, training data augmentation introduces an inherent computational cost:\nthe increased volume of data requires additional computational resources, impacting both training time and memory requirements.\n\nAs we will show below, for linear models with the sum of squares loss, training data augmentation is equivalent to adding quadratic regularization term, which implies that the computational cost of fitting a model to an augmented dataset is the same as using no augmentation at all!\n\nThis link between augmentation and regularization is useful in the other direction as well: it gives a concrete interpretation to the value of regularization hyperparameters, and can be used to avoid costly hyperparameters tuning (`np.logspace(-6, 6, 100)` much?),\nand to design regularizers that are more appropriate to the data than the simple ones (i.e sum of squares regularization used in ridge regression).\n\n## Notation\nSuppose we have a training data set comprised of $n$ pairs $x_i,\\,y_i$ for $i=0, \\dots, n-1$, where $x_i$ is the $d$ dimensional feature vector of the $i$'th training data, and $y_i$ is the corresponding label.\nHere we will assume $y_i \\in \\mathrm{R}$, however our results can be easily extended to the vector-labeled (aka multi-output) case.\nWe will also denote by $X$ the $n$-by-$d$ matrix with rows $x_0^T, \\dots, x_{n-1}^T$ and by $y$ the $n$-vector with entries $y_0, \\dots, y_{n-1}$.\n\nLet\n$a:\\mathrm{R}^d \\times \\mathcal{P}  \\mapsto \\mathrm{R}^d$ \ndenote the augmentation function\nthat given the augmentation params $p \\in \\mathcal{P}$, maps a feature vector $x$ to a transformed feature vector.\nThe augmentation parameters $p$ are usually sampled randomly from a given distribution.\nFor example, for image data, $a$ is often a composition of small shifts, rotations, brightness changes, etc. while $p$ specifies the amount of shifting, rotation and brightness change.\n\n\n## Ordinary least squares (OLS)\nLet's quickly discuss OLS so we can compare it's equations with the augmented version we will derive after.\\\nTo fit an OLS model, we find a vector of coefficients $\\theta_\\text{OLS}$ that minimizes the sum of squared training errors:\n\\begin{align*}\n    \\theta_\\text{OLS} &:= \\text{argmin} _\\theta \\sum_{i=0} ^{n-1} \\left( \n    x_i ^T \\theta - y_i\n    \\right) ^2\n    \\\\&= \\text{argmin} _\\theta \\| X \\theta - y \\|^2 \\tag{1}\n\\end{align*}\nTo solve the optimization problem (1), we solve the equation $X^TX \\theta_\\text{OLS} = X^T y$, which has time complexity $O(n d^2)$.\n\n## Augmented least squares\nWe will now fit a model by finding coefficients $\\theta_\\text{ALS}$ that minimize the expected error over the augmented training dataset:\n\\begin{align*}\n    \\theta_\\text{ALS} &:= \\text{argmin} _\\theta \\mathrm{E}  \n    \\left[\n    \\sum_{i=0} ^{n-1} \\left( \n    a\\left(x_i, p_i\\right) ^T \\theta - y_i\n    \\right) ^2\n    \\right], \\tag{2}\n\\end{align*}\nwhere the expectation is over $p_0,\\dots, p_{n-1}$, the random augmentation parameters.\nAs we will see below, $\\theta_\\text{ALS}$ depends on $a$ and the distribution of $p$ only through the 2nd order moments, which we denote by\n\\begin{align*}\n    \\mu_i &:= \\mathrm{E} \\left[a(x_i, p_i) \\right]\\\\\n    R_i &:= \\mathrm{C}\\text{ov} \\left[ a(x_i, p_i) \\right].\n\\end{align*}\n\nContinuing from (2), we use the standard trick of subtracting and adding the mean:\n\\begin{align*}\n    \\theta_\\text{ALS} &= \\text{argmin} _\\theta \\mathrm{E}  \n    \\left[\n        \\sum_{i=0} ^{n-1} \\left( \n            \\left(\n                \\mu_i^T \\theta - y_i\n            \\right)\n            + \\left(\n                a\\left(x_i, p_i\\right) - \n                \\mu_i\n            \\right)^T\\theta\n        \\right) ^2\n    \\right] \n\\end{align*}\nNote that the first term \n$\n\\left(\n    \\mu_i^T \\theta - y_i\n\\right)\n$\nis deterministic, while the second term\n$\n\\left(\n    a\\left(x_i, p_i\\right) - \n    \\mu_i\n\\right)^T\\theta\n$\nhas zero mean. Therefore\n\\begin{align*}\n    \\theta_\\text{ALS} &= \\text{argmin} _\\theta \n    \\sum_{i=0} ^{n-1} \n        \\left(\n            \\mu_i^T \\theta - y_i\n        \\right)\n        +\n        \\mathrm{E} \\left[\\left(\n            \\left(\n                a\\left(x_i, p_i\\right) - \n                \\mu_i\n            \\right)^T\\theta\n        \\right)^2 \\right] \\\\\n    &= \\text{argmin} _\\theta \n    \\| M \\theta - y\\|^2 + \\theta ^T R \\theta,\n    \\tag{3}\n\\end{align*}\nwhere $M$ is the $n$-by-$d$ matrix whose rows are $\\mu_0^T, \\dots, \\mu_{n-1}^T$, and \n$$\nR := \\sum_{i=0} ^{n-1} R_i.\n$$\nEquation (3) shows exactly what we set to prove - fitting a model on augmented training dataset, is equivalent to fitting a non-augmented, but quadratically regularized, least squares model.\nWe just replace $X$ with it's mean, and use the sum of all covariances as the regularization matrix.\n\nTo solve the optimization problem (3), we solve the equation $(X^T X + R) \\theta_\\text{ALS} = X^T y$, which has the same $O(n d^2)$ complexity as OLS.\n\n\n## Ridge regression\nRide regression (aka Tykhonov regularization) has the form (3) with $M=X$ and $R=\\lambda I$.\nAs an augmentation, it can be interpreted as follows:\nperturb each feature vector by a zero mean noise, with variance $\\lambda/n$, uncorrelated across features.\\\nThis interpretation of $\\lambda$ can be used to set it (at least roughly):\njust think what level of perturbation $\\sigma$ is reasonable for your features, and set  $\\lambda = n \\sigma^2$.\\\nThis also shows that when different feature are scaled differently, ridge regression is perhaps not the best fit.\nA standard deviation of 100 might be reasonable for a feature with values in the order of millions, but it is probably not suitable for a feature with values in the order of 1.\nIn these cases, we may use a diagonal $R$:\n\\begin{align*}\n    R= n \\, \\text{diag} \\left(\n        \\sigma_0^2, \\dots, \\sigma_{d-1}^2\n    \\right)\n\\end{align*}\nwhere $\\sigma_i$ is the standard deviation of the perturbation of feature $i$.\n\nAnother option is to scale the transformations before fit, e.g using sklearn's `StandardScaler`.\nWith all features scaled to have unit variance, setting $\\lambda = n \\, 10 ^{-6}$ is a sensible rule of thumb, as it is often reasonable to assume a $0.1\\%$ perturbation.\n\nNote that often the model includes an intercept (aka constant) term by adding a column of ones to $X$. Since this column remain unchanged through any augmenting transformation, the corresponding row and column of $R$ should be all zeros.\n\n## Example\nFor the example we are gonna use the [House Sales in King County, USA dataset](https://www.kaggle.com/datasets/harlfoxem/housesalesprediction/data).\nEach row describes a house, sold between May 2014 and May 2015. Our goal will be to predict the log price given features like number of rooms, area, and geography.\n\nNote: several decisions outlined below weren't necessarily the most effective\\,;\\, rather, they were chosen to showcase different modelling techniques in the context of augmentation via regularization.\n\n\nLet's begin by importing everything we will need, loading our data, and adding some columns.\n\nWe will want a polynomial (rather than linear) dependency on the age of the house:\n\nWe do a 10-90 train-test split to demonstrate the effectiveness of augmentation when we have little data.\n\nThere is no reason to expect a linear relationship between the house geographical coordinates and it's price. \n\\\nHowever, we do expect a strong dependency between price and location in the sense that houses with similar features should share similar prices when located in close geographical proximity.\n\\\nOne way to model this is to cluster the data geographically, and tag each house with the cluster it belongs to using one hot encoding:\n\n\nWe will evaluate our models by their R squared score. From a quick glance over Kaggle, it seems that sophisticated and advanced models (e.g XGBoost) can achieve a score of about 0.9. Let's see if we can get there using a linear model.\n\nLet's start with a vanilla linear model, without any regularization/augmentations.\n\nNot bad, but we do have some overfitting.\nLet's see if we can improve generalization with regularization/augmentation.\nFirst we try ridge regression:\n\nThat didn't really help. That makes sense since using a diagonal regularization matrix doesn't make sense for our correlated features.\\\nLet's see if we can do better by using augmentations that are more appropriate for our data.\n\nFirst let's build a class for linear models with augmentation via regularization.\\\nWe will pass to the constructor a callable that takes the input features and returns their mean and (sum of) covariance after the augmentation, since as we shown above these are all we need from the augmentations.\\\nSince often the transformations of different features are uncorrelated, it is convenient to specify features in groups, and assume zero covariance for features that are not in the same group (i.e a block diagonal covariance matrix).\n\nHere are the augmentations we are gonna use:\\\nWith 10% probability, a bathroom is counted as half a bedroom.\n\nA 5% perturbation for the features         \n`sqft_living,\nsqft_lot,\nsqft_above,\nsqft_basement,\nsqft_lot15,\nsqft_living15`, uncorrelated across the features.\n\nA perturbation of 0.01 for the features `floors, waterfront, view, condition, grade`, uncorrelated across the features\n\nperturbing `age` with a uniform distribution between -1 and 1. We need to calculate the moments for the power of age accordingly.\n\nAnd finally, with probability 50%, the geo cluster is changed to one of it's neighbors.\n\nLe't fit the augmented model and see how we did:\n\nWe managed to improve the test accuracy, and reduce overfit.\n\n## Beyond least squares\nIs it possible to extend the result to models that use a non-quadratic loss (e.g logistic regression)?\nWell the proof heavily relies on that, so probably not, but let's if we can at least can an approximate result using a 2nd order taylor approximation for the loss.\n\nThe goal is to (approximately) express\n\\begin{align*}\n    \\mathrm{E}  \n    \\left[\n    \\sum_{i=0} ^{n-1} l \\left( \n    a\\left(x_i, p_i\\right) ^T \\theta \\,;\\, y_i\n    \\right)\n    \\right],\n\\end{align*}\nas a sum of a non-augmented loss term, and a regularization term.\nHere, $l(\\hat{y}\\,;\\,y)$ measures how bad is the prediction $\\hat{y}$, given the true value $y$ (the loss).\\\nFor example, for logistic regression we use the logistic loss\n$$\nl(\\hat{y}; y) = \\log \\left( 1 + \\exp \\left(-y \\, \\hat{y} \\right) \\right)\n$$\n(with $y \\in \\{ -1, 1 \\}$).\\\nLet's expand \n$l \\left( \na\\left(x_i, p_i\\right) ^T \\theta\\,;\\,y_i\n\\right)$\naround $\\mu_i ^T \\theta$ and simplify:\n\\begin{align*}\n\\mathrm{E}  \n\\left[\n\\sum_{i=0} ^{n-1} l \\left( \na\\left(x_i, p_i\\right) ^T \\theta \\,;\\, y_i\n\\right)\n\\right]\n\\approx\n\\sum_{i=0} ^{n-1} l(\\mu_i ^T \\theta\\,;\\,y_i) + \\frac{1}{2}  l'' \\left( \\mu_i ^T \\theta\\,;\\,y_i \\right) \\theta^T R \\theta\n\\end{align*}\n(the order-1 term vanishes as it has zero mean, similar to [the delta method](https://en.wikipedia.org/wiki/Delta_method#)).\\\nSo like in the least squares case, in the loss term we just replace each $x$ with it's mean.\nBut, the regularization term is not quadratic, since we have the second derivative factor which is not constant (unless the loss is quadratic...).\n\nI use this  result to tell myself that it is ok to select an $R$ for a quadratic regularization based on the covariance of an augmentation, as long as the covariance is small (usually correct for augmentations), and $l''$ is bounded (correct for logistic regression).\n\n\n\n\n","srcMarkdownNoYaml":"\n\n# Augmentation is Regularization\nTraining data augmentation enhances the training dataset by applying transformations to existing training data instances. \nThe specific transformations vary depending on the type of data involved, and this flexibility allows to leverage domain knowledge, such as known invariants, effectively.\nThe goal is to introduce variability and increase the diversity of the training set, allowing the model to better generalize to unseen data and exhibit improved robustness.\nDespite the advantages, training data augmentation introduces an inherent computational cost:\nthe increased volume of data requires additional computational resources, impacting both training time and memory requirements.\n\nAs we will show below, for linear models with the sum of squares loss, training data augmentation is equivalent to adding quadratic regularization term, which implies that the computational cost of fitting a model to an augmented dataset is the same as using no augmentation at all!\n\nThis link between augmentation and regularization is useful in the other direction as well: it gives a concrete interpretation to the value of regularization hyperparameters, and can be used to avoid costly hyperparameters tuning (`np.logspace(-6, 6, 100)` much?),\nand to design regularizers that are more appropriate to the data than the simple ones (i.e sum of squares regularization used in ridge regression).\n\n## Notation\nSuppose we have a training data set comprised of $n$ pairs $x_i,\\,y_i$ for $i=0, \\dots, n-1$, where $x_i$ is the $d$ dimensional feature vector of the $i$'th training data, and $y_i$ is the corresponding label.\nHere we will assume $y_i \\in \\mathrm{R}$, however our results can be easily extended to the vector-labeled (aka multi-output) case.\nWe will also denote by $X$ the $n$-by-$d$ matrix with rows $x_0^T, \\dots, x_{n-1}^T$ and by $y$ the $n$-vector with entries $y_0, \\dots, y_{n-1}$.\n\nLet\n$a:\\mathrm{R}^d \\times \\mathcal{P}  \\mapsto \\mathrm{R}^d$ \ndenote the augmentation function\nthat given the augmentation params $p \\in \\mathcal{P}$, maps a feature vector $x$ to a transformed feature vector.\nThe augmentation parameters $p$ are usually sampled randomly from a given distribution.\nFor example, for image data, $a$ is often a composition of small shifts, rotations, brightness changes, etc. while $p$ specifies the amount of shifting, rotation and brightness change.\n\n\n## Ordinary least squares (OLS)\nLet's quickly discuss OLS so we can compare it's equations with the augmented version we will derive after.\\\nTo fit an OLS model, we find a vector of coefficients $\\theta_\\text{OLS}$ that minimizes the sum of squared training errors:\n\\begin{align*}\n    \\theta_\\text{OLS} &:= \\text{argmin} _\\theta \\sum_{i=0} ^{n-1} \\left( \n    x_i ^T \\theta - y_i\n    \\right) ^2\n    \\\\&= \\text{argmin} _\\theta \\| X \\theta - y \\|^2 \\tag{1}\n\\end{align*}\nTo solve the optimization problem (1), we solve the equation $X^TX \\theta_\\text{OLS} = X^T y$, which has time complexity $O(n d^2)$.\n\n## Augmented least squares\nWe will now fit a model by finding coefficients $\\theta_\\text{ALS}$ that minimize the expected error over the augmented training dataset:\n\\begin{align*}\n    \\theta_\\text{ALS} &:= \\text{argmin} _\\theta \\mathrm{E}  \n    \\left[\n    \\sum_{i=0} ^{n-1} \\left( \n    a\\left(x_i, p_i\\right) ^T \\theta - y_i\n    \\right) ^2\n    \\right], \\tag{2}\n\\end{align*}\nwhere the expectation is over $p_0,\\dots, p_{n-1}$, the random augmentation parameters.\nAs we will see below, $\\theta_\\text{ALS}$ depends on $a$ and the distribution of $p$ only through the 2nd order moments, which we denote by\n\\begin{align*}\n    \\mu_i &:= \\mathrm{E} \\left[a(x_i, p_i) \\right]\\\\\n    R_i &:= \\mathrm{C}\\text{ov} \\left[ a(x_i, p_i) \\right].\n\\end{align*}\n\nContinuing from (2), we use the standard trick of subtracting and adding the mean:\n\\begin{align*}\n    \\theta_\\text{ALS} &= \\text{argmin} _\\theta \\mathrm{E}  \n    \\left[\n        \\sum_{i=0} ^{n-1} \\left( \n            \\left(\n                \\mu_i^T \\theta - y_i\n            \\right)\n            + \\left(\n                a\\left(x_i, p_i\\right) - \n                \\mu_i\n            \\right)^T\\theta\n        \\right) ^2\n    \\right] \n\\end{align*}\nNote that the first term \n$\n\\left(\n    \\mu_i^T \\theta - y_i\n\\right)\n$\nis deterministic, while the second term\n$\n\\left(\n    a\\left(x_i, p_i\\right) - \n    \\mu_i\n\\right)^T\\theta\n$\nhas zero mean. Therefore\n\\begin{align*}\n    \\theta_\\text{ALS} &= \\text{argmin} _\\theta \n    \\sum_{i=0} ^{n-1} \n        \\left(\n            \\mu_i^T \\theta - y_i\n        \\right)\n        +\n        \\mathrm{E} \\left[\\left(\n            \\left(\n                a\\left(x_i, p_i\\right) - \n                \\mu_i\n            \\right)^T\\theta\n        \\right)^2 \\right] \\\\\n    &= \\text{argmin} _\\theta \n    \\| M \\theta - y\\|^2 + \\theta ^T R \\theta,\n    \\tag{3}\n\\end{align*}\nwhere $M$ is the $n$-by-$d$ matrix whose rows are $\\mu_0^T, \\dots, \\mu_{n-1}^T$, and \n$$\nR := \\sum_{i=0} ^{n-1} R_i.\n$$\nEquation (3) shows exactly what we set to prove - fitting a model on augmented training dataset, is equivalent to fitting a non-augmented, but quadratically regularized, least squares model.\nWe just replace $X$ with it's mean, and use the sum of all covariances as the regularization matrix.\n\nTo solve the optimization problem (3), we solve the equation $(X^T X + R) \\theta_\\text{ALS} = X^T y$, which has the same $O(n d^2)$ complexity as OLS.\n\n\n## Ridge regression\nRide regression (aka Tykhonov regularization) has the form (3) with $M=X$ and $R=\\lambda I$.\nAs an augmentation, it can be interpreted as follows:\nperturb each feature vector by a zero mean noise, with variance $\\lambda/n$, uncorrelated across features.\\\nThis interpretation of $\\lambda$ can be used to set it (at least roughly):\njust think what level of perturbation $\\sigma$ is reasonable for your features, and set  $\\lambda = n \\sigma^2$.\\\nThis also shows that when different feature are scaled differently, ridge regression is perhaps not the best fit.\nA standard deviation of 100 might be reasonable for a feature with values in the order of millions, but it is probably not suitable for a feature with values in the order of 1.\nIn these cases, we may use a diagonal $R$:\n\\begin{align*}\n    R= n \\, \\text{diag} \\left(\n        \\sigma_0^2, \\dots, \\sigma_{d-1}^2\n    \\right)\n\\end{align*}\nwhere $\\sigma_i$ is the standard deviation of the perturbation of feature $i$.\n\nAnother option is to scale the transformations before fit, e.g using sklearn's `StandardScaler`.\nWith all features scaled to have unit variance, setting $\\lambda = n \\, 10 ^{-6}$ is a sensible rule of thumb, as it is often reasonable to assume a $0.1\\%$ perturbation.\n\nNote that often the model includes an intercept (aka constant) term by adding a column of ones to $X$. Since this column remain unchanged through any augmenting transformation, the corresponding row and column of $R$ should be all zeros.\n\n## Example\nFor the example we are gonna use the [House Sales in King County, USA dataset](https://www.kaggle.com/datasets/harlfoxem/housesalesprediction/data).\nEach row describes a house, sold between May 2014 and May 2015. Our goal will be to predict the log price given features like number of rooms, area, and geography.\n\nNote: several decisions outlined below weren't necessarily the most effective\\,;\\, rather, they were chosen to showcase different modelling techniques in the context of augmentation via regularization.\n\n\nLet's begin by importing everything we will need, loading our data, and adding some columns.\n\nWe will want a polynomial (rather than linear) dependency on the age of the house:\n\nWe do a 10-90 train-test split to demonstrate the effectiveness of augmentation when we have little data.\n\nThere is no reason to expect a linear relationship between the house geographical coordinates and it's price. \n\\\nHowever, we do expect a strong dependency between price and location in the sense that houses with similar features should share similar prices when located in close geographical proximity.\n\\\nOne way to model this is to cluster the data geographically, and tag each house with the cluster it belongs to using one hot encoding:\n\n\nWe will evaluate our models by their R squared score. From a quick glance over Kaggle, it seems that sophisticated and advanced models (e.g XGBoost) can achieve a score of about 0.9. Let's see if we can get there using a linear model.\n\nLet's start with a vanilla linear model, without any regularization/augmentations.\n\nNot bad, but we do have some overfitting.\nLet's see if we can improve generalization with regularization/augmentation.\nFirst we try ridge regression:\n\nThat didn't really help. That makes sense since using a diagonal regularization matrix doesn't make sense for our correlated features.\\\nLet's see if we can do better by using augmentations that are more appropriate for our data.\n\nFirst let's build a class for linear models with augmentation via regularization.\\\nWe will pass to the constructor a callable that takes the input features and returns their mean and (sum of) covariance after the augmentation, since as we shown above these are all we need from the augmentations.\\\nSince often the transformations of different features are uncorrelated, it is convenient to specify features in groups, and assume zero covariance for features that are not in the same group (i.e a block diagonal covariance matrix).\n\nHere are the augmentations we are gonna use:\\\nWith 10% probability, a bathroom is counted as half a bedroom.\n\nA 5% perturbation for the features         \n`sqft_living,\nsqft_lot,\nsqft_above,\nsqft_basement,\nsqft_lot15,\nsqft_living15`, uncorrelated across the features.\n\nA perturbation of 0.01 for the features `floors, waterfront, view, condition, grade`, uncorrelated across the features\n\nperturbing `age` with a uniform distribution between -1 and 1. We need to calculate the moments for the power of age accordingly.\n\nAnd finally, with probability 50%, the geo cluster is changed to one of it's neighbors.\n\nLe't fit the augmented model and see how we did:\n\nWe managed to improve the test accuracy, and reduce overfit.\n\n## Beyond least squares\nIs it possible to extend the result to models that use a non-quadratic loss (e.g logistic regression)?\nWell the proof heavily relies on that, so probably not, but let's if we can at least can an approximate result using a 2nd order taylor approximation for the loss.\n\nThe goal is to (approximately) express\n\\begin{align*}\n    \\mathrm{E}  \n    \\left[\n    \\sum_{i=0} ^{n-1} l \\left( \n    a\\left(x_i, p_i\\right) ^T \\theta \\,;\\, y_i\n    \\right)\n    \\right],\n\\end{align*}\nas a sum of a non-augmented loss term, and a regularization term.\nHere, $l(\\hat{y}\\,;\\,y)$ measures how bad is the prediction $\\hat{y}$, given the true value $y$ (the loss).\\\nFor example, for logistic regression we use the logistic loss\n$$\nl(\\hat{y}; y) = \\log \\left( 1 + \\exp \\left(-y \\, \\hat{y} \\right) \\right)\n$$\n(with $y \\in \\{ -1, 1 \\}$).\\\nLet's expand \n$l \\left( \na\\left(x_i, p_i\\right) ^T \\theta\\,;\\,y_i\n\\right)$\naround $\\mu_i ^T \\theta$ and simplify:\n\\begin{align*}\n\\mathrm{E}  \n\\left[\n\\sum_{i=0} ^{n-1} l \\left( \na\\left(x_i, p_i\\right) ^T \\theta \\,;\\, y_i\n\\right)\n\\right]\n\\approx\n\\sum_{i=0} ^{n-1} l(\\mu_i ^T \\theta\\,;\\,y_i) + \\frac{1}{2}  l'' \\left( \\mu_i ^T \\theta\\,;\\,y_i \\right) \\theta^T R \\theta\n\\end{align*}\n(the order-1 term vanishes as it has zero mean, similar to [the delta method](https://en.wikipedia.org/wiki/Delta_method#)).\\\nSo like in the least squares case, in the loss term we just replace each $x$ with it's mean.\nBut, the regularization term is not quadratic, since we have the second derivative factor which is not constant (unless the loss is quadratic...).\n\nI use this  result to tell myself that it is ok to select an $R$ for a quadratic regularization based on the covariance of an augmentation, as long as the covariance is small (usually correct for augmentations), and $l''$ is bounded (correct for logistic regression).\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"augmentation_example.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.543","theme":"cosmo","title-block-banner":true,"title":"Augmentation is Regularization","author":"Tom Shlomo","date":"2024-01-15","categories":["machine learning","regularization"],"description":"On the equivalence of training data augmentation and quadratic regularization for linear models - a very useful (but not well known) result."},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}